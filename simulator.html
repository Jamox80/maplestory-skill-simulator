<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="ui/favicon.ico">
    <title>Artale技能模擬器</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-13D7FF11WN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-13D7FF11WN');
    </script>
    <script src="data.js"></script>
    <style>
        /* --- PC 網頁版通用樣式調整 (魔法書卷風格) --- */

        body {
            /* 確保背景舒適且不過於花俏，如果還沒有羊皮紙紋理，可以考慮加入 */
            background-color: #f0e6d6;
            /* 柔和的羊皮紙底色作為備用 */

            /* --- 新的三段式背景設定 --- */
            /* 順序很重要：上層、下層、中層(最底)。請確認圖片路徑 ui/background-top.png, ui/background-middle.png, ui/background-bottom.png 是否正確 */
            background-image:
                url('ui/parchment_texture-top.png'),
                /* 上方圖片 */
                url('ui/parchment_texture-bottom.png'),
                /* 下方圖片 */
                url('ui/parchment_texture-middle.png');
            /* 中間重複圖片 */
            background-repeat:
                no-repeat,
                /* 上方不重複 */
                no-repeat,
                /* 下方不重複 */
                repeat-y;
            /* 中間垂直重複 */
            background-position:
                center top,
                /* 上方置頂 */
                center bottom,
                /* 下方置底 */
                center top;
            /* 中間從頂部開始 */
            background-size:
                100% auto,
                /* 圖片寬度100%，高度自動 */
                100% auto,
                /* 圖片寬度100%，高度自動 */
                100% auto;
            /* 圖片寬度100%，高度自動 */
            background-attachment: scroll;
            /* PC版：背景隨頁面滾動 */
            font-family: 'Segoe UI', Arial, sans-serif;
            /* 常用且清晰的字體，或使用您喜歡的Google Fonts */
            line-height: 1.6;
            /* 增加行高，提升閱讀舒適度 */
            color: #333;
            /* 預設文字顏色 */
            display: flex;
            /* 讓body成為flex容器 */
            flex-direction: column;
            /* 垂直排列 */
            align-items: center;
            /* 水平居中所有內容 */
            min-height: 100vh;
            /* 確保內容至少佔據整個視窗高度 */
        }

        /* --- 新增：職業徽章浮水印 --- */
        body::before {
            content: '';
            /* 偽元素必需的屬性 */
            position: fixed;
            /* 固定在視窗上，不隨滾動移動 */
            bottom: 20px;
            /* 距離視窗底部 */
            left: 74%;
            /* 從左側 50% 開始 */
            transform: translateX(-50%);
            /* 使用 transform 精確水平置中 */
            width: 300px;
            /* 設定一個適合的寬度 */
            height: 300px;
            /* 設定一個適合的高度 */
            background-image: var(--emblem-bg-url);
            /* 使用CSS變數，由JS動態設定 */
            background-position: center center;
            background-repeat: no-repeat;
            background-size: contain;
            /* 確保徽章完整顯示並保持比例 */
            opacity: 0.3;
            /* 設定非常淡的透明度，使其成為浮水印 */
            z-index: -1;
            /* 將其置於內容之後，但在 body 背景之上 */
            pointer-events: none;
            /* 確保浮水印不會干擾滑鼠點擊 */
        }

        h1 {
            font-family: 'Cinzel Decorative', serif;
            /* 更具裝飾性的標題字體 */
            color: #4a2d1d;
            /* 深棕色，與書卷風格更搭 */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
            /* 增加文字陰影，提升立體感 */
            margin-top: 50px;
            /* 在標題上方增加間距，使其不會緊貼頂部 */
            margin-bottom: 30px;
            /* 增加與控制區的間距 */
            font-size: 2.5em;
            /* 調整標題大小 */
            letter-spacing: 2px;
            /* 增加字元間距，更顯大氣 */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .title-link {
            text-decoration: none;
            color: inherit;
        }

        hB {
            font-family: 'Cinzel Decorative', serif;
            /* 更具裝飾性的標題字體 */
            color: #4a2d1d;
            /* 深棕色，與書卷風格更搭 */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
            /* 增加文字陰影，提升立體感 */
            font-size: 2.5em;
            /* 調整標題大小 */
            letter-spacing: 2px;
            /* 增加字元間距，更顯大氣 */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .title-icon {
            height: 3.5em;
            /* 讓圖示高度與文字大小協調 */
            margin-right: 30px;
            /* 圖示與文字的間距 */
            vertical-align: middle;
            /* 確保垂直對齊 */
        }

        .controls {
            background-color: rgba(255, 255, 255, 0.5);
            /* 輕微透明背景 */
            padding: 15px 30px;
            /* 增加內邊距 */
            border-radius: 10px;
            /* 圓潤邊角 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            /* 較明顯的陰影，提升層次感 */
            margin-bottom: 25px;
            /* 與主內容區的間距 */
            display: flex;
            /* 確保內部元素對齊 */
            align-items: center;
            justify-content: center;
            gap: 10px;
            /* 控制元素之間的間距 */
            flex-wrap: wrap;
            /* 當空間不足時自動換行 */
        }

        .controls label {
            font-size: 1.1em;
            /* 調整標籤字體大小 */
            color: #5d4037;
            /* 深棕色 */
        }

        .controls select,
        .controls input[type="number"] {
            padding: 10px 15px;
            /* 增加輸入框和選單的內邊距 */
            border: 2px solid #795548;
            /* 更明顯的邊框 */
            border-radius: 8px;
            /* 圓角 */
            background-color: #fefefe8c;
            /* 淺色背景 */
            color: #4e342e;
            /* 深文字 */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.158);
            /* 內陰影，提升質感 */
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            /* 鼠標懸停過渡 */
        }

        .controls select:focus,
        .controls input[type="number"]:focus {
            border-color: #a1887f;
            /* 聚焦時的邊框顏色 */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(161, 136, 127, 0.5);
            /* 聚焦時的陰影 */
            outline: none;
            /* 移除瀏覽器預設的聚焦外框 */
        }

        .reset-button,
        .share-button,
        .contribute-button {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        .reset-button {
            background-color: #d32f2f;
        }

        .reset-button:hover {
            background-color: #c62828;
        }

        .share-button {
            background-color: #1976d2;
        }

        .share-button:hover {
            background-color: #1565c0;
        }

        .contribute-button {
            background-color: #388e3c;
        }

        .contribute-button:hover {
            background-color: #2e7d32;
        }

        .container {
            display: flex;
            /* 保持 flex 佈局，實現左右分欄 */
            justify-content: center;
            gap: 30px;
            /* 增加技能樹和總結區塊的間距 */
            max-width: 1200px;
            /* 限制整體內容最大寬度，避免過寬 */
            width: 90%;
            /* 佔據大部分可用寬度 */
            margin-bottom: 40px;
            /* 增加與頁面底部的間距 */
            flex-grow: 1;
            /* 讓主內容區塊擴展以填滿剩餘的垂直空間 */
            align-items: flex-start;
            /* 讓技能樹和總結區塊從頂部對齊，解決空白問題 */
        }

        .skill-tree,
        .summary {
            background-color: rgba(252, 242, 223, 0.5);
            /* 讓內容區塊有近乎不透明的紙張感 */
            border: 3px solid #795548;
            /* 更粗的書卷邊框 */
            border-radius: 12px;
            /* 更圓潤的邊角 */
            padding: 40px;
            /* 增加內邊距，模擬書頁的寬廣邊緣 */
            box-shadow:
                0 8px 20px rgba(0, 0, 0, 0.3),
                /* 顯著的下層陰影 */
                inset 0 0 0 6px rgba(181, 158, 145, 0.4);
            /* 內邊框的陰影，模擬紙張厚度 */
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            /* 平滑的懸停過渡 */
            position: relative;
            overflow: hidden;
            /* 模擬輕微捲曲的效果 */
        }

        .skill-tree:hover,
        .summary:hover {
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.4),
                inset 0 0 0 6px rgba(181, 158, 145, 0.5);
        }

        .skill-tree {
            width: 80%;
            /* 技能樹佔比更大 */
        }

        .summary {
            width: 20%;
            /* 總結區塊佔比 */
            position: sticky;
            /* 讓總結區塊在滾動時懸浮 */
            top: 150px;
            /* 距離頂部 150px，讓它位置更低 */
            height: fit-content;
            /* 高度自適應內容，避免不必要的拉伸 */
        }

        h2 {
            font-family: 'Cinzel Decorative', cursive;
            /* 與H1風格一致 */
            color: #795548;
            /* 深棕色 */
            border-bottom: 3px solid #795548;
            /* 更粗的底線 */
            padding-bottom: 8px;
            margin-bottom: 25px;
            text-align: center;
            /* 標題居中 */
        }

        /* 技能項目 (skill-item) 內部的微調 */
        .skill-item {
            padding: 12px;
            /* 增加內邊距 */
            margin-bottom: 15px;
            /* 增加間距 */
            background-color: rgba(255, 255, 255, 0.65);
            /* 輕微透明，讓紋理透出 */
            border: 1px solid #bcaaa4;
            /* 細緻邊框 */
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            /* 輕微陰影 */
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            /* 調整過渡時間以匹配點數總結區塊 */
            transform: perspective(800px) rotateX(2deg);
            /* 增加基礎的3D傾斜效果，類似點數總結區塊 */
        }

        .skill-item:hover {
            transform: perspective(800px) rotateX(0deg) translateY(-2px);
            /* 懸停時變平並輕微上浮，模擬點數總結區塊的效果 */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            /* 懸停時加深陰影 */
        }

        .skill-header {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .skill-icon {
            width: 40px;
            /* 調整圖示大小，使其在PC上更顯眼 */
            height: 40px;
            margin-right: 15px;
        }

        .skill-name {
            /* 這裡的修改：移除 flex-grow: 1; 並添加防止換行的屬性 */
            /* flex-grow: 1; <-- 移除這行 */
            flex-shrink: 1;
            /* 允許縮小 */
            overflow: hidden;
            /* 隱藏溢出內容 */
            text-overflow: ellipsis;
            /* 溢出時顯示省略號 */
            white-space: nowrap;
            /* 強制文字不換行 */
            font-size: 1.1em;
            /* 調整技能名稱字體 */
            color: #4e342e;
            /* 與主題色協調 */
            /* padding-right: 10px; 保持原本的間距 */
            /* display: flex; align-items: center; 保持原本的flex對齊 */
        }

        .skill-level-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            /* 保持按鈕間距 */
            flex-shrink: 0;
            /* 阻止這個區塊縮小 */
            white-space: nowrap;
            /* 阻止按鈕換行 */
            margin-left: auto;
            /* 將控制按鈕推到右邊 */
        }

        .skill-level-controls button {
            padding: 8px 15px;
            /* 按鈕更大，更易點擊 */
            border-radius: 6px;
            font-size: 1em;
            font-weight: bold;
            text-transform: uppercase;
            /* 文字大寫，增加力量感 */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            /* 按鈕陰影 */
            background-color: #a1887f;
            /* 淺棕色，與書卷風格協調 */
            color: #f5f5f5;
            /* 淺色文字以確保可讀性 */
            border: 1px solid #795548;
            /* 深棕色邊框 */
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .skill-level-controls button:hover:not(:disabled) {
            background-color: #8d6e63;
            /* 懸停時加深顏色 */
        }

        .skill-level-controls button:disabled {
            background-color: #d7ccc8;
            /* 禁用時的顏色 */
            color: #a1887f;
            cursor: not-allowed;
            border-color: #bcaaa4;
        }

        .skill-level-controls .max-button {
            background-color: #4caf50;
            /* 點滿按鈕更亮的綠色 */
        }

        .skill-level-controls .max-button:hover:not(:disabled) {
            background-color: #388e3c;
        }

        .skill-current-level {
            font-size: 1.1em;
            min-width: 40px;
            /* 確保顯示足夠空間 */
            color: #6d4c41;
            /* 調整顏色 */
        }

        .skill-level-controls .skill-level-input {
            font-size: 1.1em;
            width: 45px;
            color: #6d4c41;
            text-align: center;
            border: 1px solid #bcaaa4;
            border-radius: 4px;
            background-color: #f5f5f5;
            appearance: textfield;
        }

        .skill-level-controls .skill-level-input::-webkit-outer-spin-button,
        .skill-level-controls .skill-level-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .skill-prerequisites {
            font-size: 0.85em;
            /* 調整字體大小 */
            color: #6d4c41;
            /* 更深的顏色 */
            margin-top: 10px;
            /* 與上方內容間距 */
            padding-top: 8px;
            /* 內邊距 */
            border-top: 1px dashed #d7ccc8;
            /* 虛線分隔，更具書卷感 */
        }

        .skill-prerequisites .prereq-met {
            color: #388e3c;
            /* 更深的綠色 */
        }

        .skill-prerequisites .prereq-unmet {
            color: #d32f2f;
            /* 更深的紅色 */
        }

        .skill-description-area {
            background-color: rgba(245, 245, 245, 0.9);
            /* 略淺的背景，與技能項目主體有層次 */
            border-top: 1px solid #bcaaa4;
            padding: 12px;
            margin-top: 15px;
            border-radius: 6px;
        }

        .skill-description-area .current-level-effect {
            color: #1976d2;
            /* 調整藍色 */
        }

        .skill-description-area .full-description {
            color: #5d4037;
            /* 深棕色 */
        }

        /* 新增：垂直分隔線樣式 */
        .vertical-separator {
            border-left: 1px solid #d7ccc8;
            /* 垂直線條，顏色與其他分隔線協調 */
            margin: 0 15px;
            /* 左右間距 */
            align-self: stretch;
            /* 讓分隔線自動延展高度 */
        }

        /* --- 新增：推薦配點詳情區塊樣式 --- */
        .build-details-container {
            width: 80%;
            max-width: 900px;
            background-color: rgba(253, 249, 241, 0.95);
            border: 2px solid #795548;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .build-details-container h3 {
            font-family: 'Cinzel Decorative', serif;
            color: #4a2d1d;
            text-align: center;
            margin: 0 0 10px 0;
            font-size: 1.6em;
        }

        .build-details-container h4 {
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            color: #5d4037;
            border-bottom: 1px solid #d7ccc8;
            padding-bottom: 5px;
            margin: 10px 0 5px 0;
        }

        .build-details-container p {
            color: #4e342e;
            line-height: 1.7;
            white-space: pre-wrap;
            /* 讓換行符號 (\n) 生效 */
            margin: 0;
        }

        .build-details-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        /* --- 回到頂部按鈕 --- */
        #backToTopBtn {
            position: fixed;
            bottom: 30px;
            right: 280px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #db4509;
            /* 與主題一致的棕色 */
            color: white;
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            font-size: 30px;
            width: 50px;
            height: 50px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #backToTopBtn.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #backToTopBtn:hover {
            background-color: #5d4037;
            /* 懸停時加深顏色 */
        }

        /* --- 手機版適應性調整 (Media Queries) --- */
        @media (max-width: 768px) {

            /* 1. 整體與標題 */
            body {
                padding: 0 10px;
                /* 調整 body 邊距，避免內容緊貼螢幕邊緣 */
                -webkit-text-size-adjust: 100%;
                /* 防止 iOS 橫向時自動放大字體 */
                background-attachment: fixed;
                /* 手機版：背景固定，此設定會應用到所有背景層 */
                /* background-position 和 background-size 已在PC版主要規則中設定，此處不需覆蓋 */
            }

            h1 {
                font-size: 1.8em;
                /* 調整標題大小 */
                margin: 25px 0;
                /* 調整標題上下間距 */
            }

            /* 2. 控制區塊 */
            .controls {
                flex-direction: column;
                /* 控制區塊垂直堆疊 */
                width: 100%;
                padding: 15px;
                gap: 15px;
                /* 縮小元素間距 */
                box-sizing: border-box;
            }

            /* 新增：用於包裹 label 和 input 的群組 */
            .control-group {
                display: flex;
                align-items: center;
                width: 100%;
                gap: 10px;
                /* label 和 input 之間的間距 */
            }

            /* 讓群組和按鈕容器佔滿整行 */
            .controls .control-group,
            .controls .action-buttons {
                width: 100%;
                margin: 0;
                /* 移除所有外邊距 */
                box-sizing: border-box;
            }

            .action-buttons {
                display: flex;
                gap: 10px;
            }

            .action-buttons button {
                flex: 1;
                /* 讓按鈕平分寬度 */
            }

            /* 調整群組內的 label 和 input/select */
            .control-group label {
                flex-shrink: 0;
                /* 防止標籤被壓縮 */
                margin-bottom: 0;
                /* 移除舊的 margin */
            }

            .control-group select,
            .control-group input[type="number"] {
                flex-grow: 1;
                /* 讓輸入框填滿剩餘空間 */
                width: auto;
                /* 讓 flexbox 自動計算寬度 */
            }

            /* 3. 主內容容器 */
            .container {
                flex-direction: column;
                /* 主內容區塊垂直堆疊 */
                width: 100%;
                gap: 20px;
                /* 調整技能樹與總結區塊的間距 */
            }

            /* 4. 技能樹與總結區塊 */
            .skill-tree,
            .summary {
                width: 100%;
                padding: 20px;
                /* 縮小內邊距 */
                box-sizing: border-box;
                transform: none;
                /* 移除 PC 版的 3D 傾斜效果 */
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
                /* 使用較柔和的陰影 */
            }

            .summary {
                position: static;
                /* 取消吸頂效果 */
                margin-top: 0;
            }

            .summary p {
                margin: 0.7em 0;
                /* 調整總結區塊的行間距 */
            }

            h2 {
                font-size: 1.5em;
                /* 縮小區塊標題 */
                margin-bottom: 20px;
            }

            /* 5. 技能項目 */
            .skill-item {
                padding: 10px;
                /* 調整內邊距 */
                margin-bottom: 10px;
            }

            .skill-header {
                flex-wrap: wrap;
                /* 允許換行 */
                gap: 10px 0;
                /* 增加垂直間距 */
            }

            .skill-icon {
                width: 32px;
                /* 縮小圖示 */
                height: 32px;
                margin-right: 10px;
            }

            .skill-name {
                /* 讓技能名稱和圖示佔據一行，並推開控制按鈕 */
                flex-grow: 1;
                white-space: normal;
                /* 允許名稱換行 */
                font-size: 1em;
            }

            .skill-level-controls {
                /* 讓控制按鈕佔據整行，並靠右對齊 */
                flex-basis: 100%;
                justify-content: flex-end;
                gap: 8px;
            }

            .skill-level-controls button {
                padding: 6px 12px;
                /* 調整按鈕大小 */
                font-size: 1em;
            }

            .skill-current-level {
                font-size: 1em;
                min-width: 30px;
            }

            /* 6. 前置與描述 */
            .skill-prerequisites {
                font-size: 0.8em;
                justify-content: flex-start;
                /* 文字靠左對齊 */
                text-align: left;
            }

            .skill-description-area {
                padding: 10px;
            }

            .skill-description-area .current-level-effect,
            .skill-description-area .full-description {
                font-size: 0.9em;
                /* 統一描述字體大小 */
            }

            #backToTopBtn {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }

            /* 7. 徽章浮水印 */
            body::before {
                width: 150px;
                /* 在手機上縮小徽章尺寸 */
                height: 150px;
                bottom: 10px;
                /* 調整與底部的距離 */
                left: 50%;
                opacity: 0.3;
                /* 在手機上可以稍微明顯一點 */
            }
        }

        /* --- 頁尾聯繫資訊 --- */
        .page-footer {
            text-align: center;
            margin-top: 10px;
            padding-bottom: 30px;
            color: #4a2d1d;
            /* 深棕色，與標題協調 */
            font-size: 0.8em;
            width: 100%;
        }

        .page-footer p {
            margin: 2px 0;
            /* 縮小段落的垂直間距，讓文字更緊湊 */
            font-family: 'Cinzel Decorative', serif;
            /* 使用主題字體 */
            letter-spacing: 1px;
        }

        .page-footer a {
            color: rgb(78, 94, 240);
            /* 與頁尾文字顏色協調的深棕色 */
            font-weight: bold;
            text-decoration: underline;
            /* 預設加上底線，更像連結 */
            transition: color 0.2s ease;
        }

        .page-footer a:hover {
            color: #a9c4fd;
            /* 滑鼠懸停時變為淺棕色 */
            text-decoration: none;
            /* 滑鼠懸停時移除底線 */
        }
    </style>
</head>

<body>
    <a href="index.html" class="title-link">
        <h1><img src="ui/title-icon.png" alt="標題圖示" class="title-icon">Artale技能模擬器</h1>
    </a>

    <div class="controls">
        <div class="control-group">
            <label for="professionSelect">選擇職業:</label>
            <select id="professionSelect" onchange="loadProfessionData(this.value)">
            </select>
        </div>
        <div class="control-group">
            <label for="recommendedBuildSelect">推薦配點:</label>
            <select id="recommendedBuildSelect" onchange="showBuildDetails(this.value)">
                <option value="">— 選擇一個配點 —</option>
            </select>
        </div>
        <div class="control-group">
            <label for="levelInput">當前等級:</label>
            <input type="number" id="levelInput" value="200" min="1" max="300" oninput="updateLevelFromInput()">
        </div>
        <div class="action-buttons">
            <button class="reset-button" onclick="resetSimulator()">重置</button>
            <button class="share-button" onclick="shareBuild()">分享</button>
            <button class="contribute-button" onclick="openContributionForm()">寫推薦文</button>
        </div>
    </div>

    <!-- 新增：推薦配點詳情區塊 -->
    <div id="buildDetailsContainer" class="build-details-container" style="display: none;">
        <h3 id="buildDetailName"></h3>
        <h4>配點說明</h4>
        <p id="buildDetailDescription"></p>
        <h4>技能優先序</h4>
        <p id="buildDetailPriority"></p>
        <div class="build-details-actions">
            <button id="loadBuildBtn" class="share-button">載入此配點</button>
            <button onclick="closeBuildDetails()" class="reset-button">關閉</button>
        </div>
    </div>

    <div class="container">
        <div class="skill-tree" id="skillTree">
        </div>

        <div class="summary">
            <h2>點數總結</h2>
            <p>總已分配點數: <span id="spentSp">0</span></p>
            <p>剩餘點數: <span id="remainingSp">0</span></p>
            <hr>
            <p>1轉/(2轉需求): <span id="spentSp_1stJob">0</span> / <span id="reqSp_2ndJob">0</span></p>
            <p>2轉/(3轉需求): <span id="spentSp_2ndJob_total">0</span> / <span id="reqSp_3rdJob">0</span></p>
            <p>3轉/(4轉需求): <span id="spentSp_3rdJob_total">0</span> / <span id="reqSp_4thJob">0</span></p>
        </div>
    </div>

    <footer class="page-footer">
        <HB>MADE BY JAMOX</HB>
        <p>若有任何回饋或資訊調整建議，歡迎<a href="https://discord.gg/mU52qFwY" target="_blank" rel="noopener noreferrer">點擊加入 Discord
                伺服器</a></p>

    </footer>

    <button id="backToTopBtn" title="回到頂部">▲</button>

    <script>
        // --- 所有職業的數據結構 ---
        // 新增：從 index.html 引入的職業名稱對照表，用於在 URL 的英文簡稱和 data.js 的混合鍵之間轉換
        const professionNameMap = {
            "Bishop": "主教",
            "archmage_fp": "火毒大魔導",
            "archmage_il": "冰雷大魔導",
            "Hero": "英雄",
            "Paladin": "聖騎士",
            "DarkKnight": "黑騎士",
            "Bowmaster": "箭神",
            "Marksman": "神射手",
            "Shadower": "暗影神偷",
            "NightLord": "夜使者",
            "Buccaneer": "拳霸",
            "Corsair": "槍神"
        };


        // --- 全局變數 ---
        let currentProfessionKey = "主教 (Bishop)"; // 預設選中的職業
        let currentProfessionData = allProfessionsData[currentProfessionKey];
        let skillsData = currentProfessionData.skills; // 技能數據現在會根據所選職業動態變化

        let currentSkillLevels = {};
        let spentSp = 0;
        let remainingSp = 0;
        let currentLevel = 200;

        // --- 初始化模擬器 ---
        function initializeSimulator() {
            populateProfessionDropdown();

            const urlParams = new URLSearchParams(window.location.search);
            const profFromUrl = urlParams.get('prof');
            const lvlFromUrl = urlParams.get('lvl');
            const skillsFromUrl = urlParams.get('skills');
            const buildIndexFromUrl = urlParams.get('buildIndex'); // 新增：獲取推薦配點索引

            // --- 新增：根據 URL 中的英文 key 找到 data.js 中的混合 key ---
            let targetProfessionKey = null;
            if (profFromUrl) {
                // 修正：使用更可靠的方式，透過中文名稱來查找對應的混合鍵
                // 這可以解決 archmage_fp vs Arch Mage F/P 的格式不一致問題
                const chineseName = professionNameMap[profFromUrl];
                if (chineseName) {
                    targetProfessionKey = Object.keys(allProfessionsData).find(key => key.startsWith(chineseName));
                }
            }

            // 優先處理：如果 URL 包含 buildIndex，則載入職業並顯示推薦配點詳情
            if (targetProfessionKey && buildIndexFromUrl !== null && buildIndexFromUrl !== '') {
                document.getElementById('professionSelect').value = targetProfessionKey;
                loadProfessionData(targetProfessionKey);

                const buildIndex = parseInt(buildIndexFromUrl, 10);
                if (!isNaN(buildIndex)) {
                    // 設定下拉選單的值，並呼叫函式來顯示詳情彈窗
                    document.getElementById('recommendedBuildSelect').value = buildIndex;
                    showBuildDetails(buildIndex);
                }
            } else if (targetProfessionKey && lvlFromUrl && skillsFromUrl) {
                // 其次處理：處理完整的分享連結 (直接套用配點)
                document.getElementById('professionSelect').value = targetProfessionKey;
                loadProfessionData(targetProfessionKey);
                currentLevel = parseInt(lvlFromUrl, 10);
                document.getElementById('levelInput').value = currentLevel;
                spentSp = 0;
                Object.keys(currentSkillLevels).forEach(id => currentSkillLevels[id] = 0);
                skillsFromUrl.split(',').forEach(pair => {
                    const [id, lvl] = pair.split(':');
                    const skillLevel = parseInt(lvl, 10);
                    if (id && !isNaN(skillLevel) && currentSkillLevels.hasOwnProperty(id)) {
                        currentSkillLevels[id] = skillLevel;
                        spentSp += skillLevel;
                    }
                });
                updateUI();
            } else if (targetProfessionKey) {
                // 只從首頁選擇了職業，載入該職業的預設狀態
                document.getElementById('professionSelect').value = targetProfessionKey;
                loadProfessionData(targetProfessionKey);
            } else {
                loadProfessionData(currentProfessionKey);
            }
        }
        // --- 填充職業下拉選單 ---
        function populateProfessionDropdown() {
            const selectElement = document.getElementById('professionSelect');
            for (const key in allProfessionsData) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                selectElement.appendChild(option);
            }
            selectElement.value = currentProfessionKey; // 設定預設選中項
        }

        // --- 載入指定職業數據 ---
        function loadProfessionData(professionKey) {
            currentProfessionKey = professionKey;
            currentProfessionData = allProfessionsData[currentProfessionKey];
            skillsData = currentProfessionData.skills; // 更新技能數據參考

            // --- 新增：更新背景浮水印 ---
            const englishKey = findEnglishKeyByMixedKey(professionKey);
            const emblemUrl = englishKey ? `emblems/${englishKey}.png` : ''; // 動態生成徽章路徑
            // 使用CSS變數來動態設定偽元素的背景圖片
            document.documentElement.style.setProperty('--emblem-bg-url', `url('${emblemUrl}')`);


            // 重置當前技能點數和SP
            currentSkillLevels = {};
            for (const jobStage in skillsData) {
                skillsData[jobStage].forEach(skill => {
                    currentSkillLevels[skill.id] = 0;
                });
            }
            spentSp = 0;
            currentLevel = 200; // 重置角色等級
            document.getElementById('levelInput').value = 200; // 更新等級輸入框顯示
            remainingSp = calculateMaxSp(currentLevel);

            // 修正：先渲染技能樹的HTML結構，再更新UI內容
            renderSkillTree();
            updateUI();
            updateRecommendedBuildsDropdown(); // 更新推薦配點下拉選單
        }

        // --- 計算最大 SP ---
        function calculateMaxSp(level) {
            let totalSp = 0;
            const { startingLevelForSp, jobAdvancementSpBonuses } = currentProfessionData;

            // 1. 轉職前等級不提供 SP
            if (level < startingLevelForSp) {
                return 0;
            }

            // 2. 從起始等級開始，每級給3點SP
            totalSp += (level - startingLevelForSp) * 3;

            // 3. 額外在轉職等級獲得SP
            jobAdvancementSpBonuses.forEach(bonusLevel => {
                if (level >= bonusLevel) {
                    if (bonusLevel === 120) { // 特別處理120等轉職
                        totalSp += 3; // 120等獲得3點
                    } else {
                        totalSp += 1; // 其他轉職等級獲得1點
                    }
                }
            });

            return totalSp;
        }

        // --- 更新推薦配點下拉選單 ---
        function updateRecommendedBuildsDropdown() {
            const select = document.getElementById('recommendedBuildSelect');
            select.innerHTML = '<option value="">— 選擇一個配點 —</option>'; // 重置
            closeBuildDetails(); // 切换職業時關閉詳情

            const builds = recommendedBuilds[currentProfessionKey] || [];
            builds.forEach((build, index) => {
                const option = document.createElement('option');
                option.value = index; // 使用索引作為 value
                option.textContent = build.name;
                select.appendChild(option);
            });
        }
        // --- 輔助函式：計算特定轉職階段的已分配SP ---
        function getSpentSpInJobStage(jobStageKey) {
            let sp = 0;
            if (skillsData[jobStageKey]) { // 確保使用當前職業的 skillsData
                skillsData[jobStageKey].forEach(skill => {
                    sp += currentSkillLevels[skill.id] || 0;
                });
            }
            return sp;
        }

        // --- 渲染技能樹 ---
        function renderSkillTree() {
            const skillTreeDiv = document.getElementById('skillTree');
            skillTreeDiv.innerHTML = ''; // 清空現有內容

            // 依照 jobStagesOrder 定義的順序來渲染
            currentProfessionData.jobStagesOrder.forEach(jobStageKey => {
                if (skillsData[jobStageKey] && skillsData[jobStageKey].length > 0) { // 確保該階段有技能
                    const sectionDiv = document.createElement('div');
                    sectionDiv.className = 'skill-section';
                    sectionDiv.innerHTML = `<h2>${jobStageKey}</h2>`;

                    skillsData[jobStageKey].forEach(skill => {
                        const skillItem = document.createElement('div');
                        skillItem.className = 'skill-item';
                        skillItem.setAttribute('data-skill-id', skill.id);

                        const skillHeader = document.createElement('div');
                        skillHeader.className = 'skill-header';
                        skillHeader.innerHTML = `
                            ${skill.imageUrl ? `<img src="${skill.imageUrl}" alt="${skill.name}" class="skill-icon" onerror="this.onerror=null;this.src='images/default.png';">` : ''}
                            <div class="skill-name">${skill.name}</div>
                            <div class="skill-level-controls">
                            <button onclick="decreaseSkill('${skill.id}')">-</button>
                            <input type="number" class="skill-level-input" id="${skill.id}-level" value="${currentSkillLevels[skill.id]}" min="0" max="${skill.maxLevel}" onchange="setSkillLevel('${skill.id}', this)">
                            <button onclick="increaseSkill('${skill.id}')">+</button>
                            <span>/${skill.maxLevel}</span>
                            <button onclick="maxSkill('${skill.id}')" class="max-button" id="${skill.id}-max-btn">點滿</button>
                        </div>
                        `;
                        skillHeader.onclick = (event) => {
                            event.stopPropagation();
                            toggleSkillDescription(skill.id);
                        };
                        skillItem.appendChild(skillHeader);
                        // --- 新增：前置技能顯示區塊 ---
                        const preReqsDiv = document.createElement('div');
                        preReqsDiv.className = 'skill-prerequisites';
                        preReqsDiv.id = `${skill.id}-prereqs`;
                        skillItem.appendChild(preReqsDiv);
                        // 初始化時，如果沒有前置，這個區塊會被 updateSkillPrerequisitesDisplay 隱藏
                        // 但在 renderSkillTree 結束後，updateSkillDetailsDisplay 會被呼叫，確保更新

                        const descArea = document.createElement('div');
                        descArea.className = 'skill-description-area';
                        descArea.id = `${skill.id}-description`;
                        descArea.innerHTML = `
                            <p>等級 <span id="${skill.id}-level-in-desc">${currentSkillLevels[skill.id]}</span> 效果: <span id="${skill.id}-current-effect" class="current-level-effect"></span></p>
                            <span class="vertical-separator"></span>
                            <p class="full-description" id="${skill.id}-full-description">${skill.description || "無詳細描述。"}</p>
                        `;

                        if (currentSkillLevels[skill.id] > 1) {
                            descArea.style.display = 'flex';
                        } else {
                            descArea.style.display = 'none';
                        }

                        skillItem.appendChild(descArea);
                        sectionDiv.appendChild(skillItem);
                    });
                    skillTreeDiv.appendChild(sectionDiv);
                }
            });
            // updateUI(); // 渲染後更新一次UI狀態
        }

        // --- 更新 UI 顯示 ---
        function updateUI() {
            document.getElementById('spentSp').textContent = spentSp;
            document.getElementById('remainingSp').textContent = remainingSp;

            const jobStagesOrder = currentProfessionData.jobStagesOrder;

            // --- 更新各轉職階段的點數顯示 (已配置 / 轉職需求) ---
            const spentSp1stJob = getSpentSpInJobStage(jobStagesOrder[1] || "");
            const reqSp2ndJob = currentProfessionData.spRequiredFor2ndJob || 0;
            document.getElementById('spentSp_1stJob').textContent = spentSp1stJob;
            document.getElementById('reqSp_2ndJob').textContent = reqSp2ndJob;

            const spentSp2ndJob = getSpentSpInJobStage(jobStagesOrder[2] || "");
            const spentSp2ndJobTotal = spentSp1stJob + spentSp2ndJob;
            const reqSp3rdJob = currentProfessionData.spRequiredFor3rdJob || 0;
            document.getElementById('spentSp_2ndJob_total').textContent = spentSp2ndJobTotal;
            document.getElementById('reqSp_3rdJob').textContent = reqSp3rdJob;

            const spentSp3rdJob = getSpentSpInJobStage(jobStagesOrder[3] || "");
            const spentSp3rdJobTotal = spentSp2ndJobTotal + spentSp3rdJob;
            const reqSp4thJob = currentProfessionData.spRequiredFor4thJob || 0;
            document.getElementById('spentSp_3rdJob_total').textContent = spentSp3rdJobTotal;
            document.getElementById('reqSp_4thJob').textContent = reqSp4thJob;

            // --- 更新所有技能的按鈕狀態和詳情 ---
            currentProfessionData.jobStagesOrder.forEach(jobStageKey => {
                if (skillsData[jobStageKey]) {
                    skillsData[jobStageKey].forEach(skill => {
                        const levelInput = document.getElementById(`${skill.id}-level`);
                        if (levelInput) {
                            levelInput.value = currentSkillLevels[skill.id];

                            const increaseBtn = levelInput.nextElementSibling;
                            const decreaseBtn = levelInput.previousElementSibling;
                            const maxBtn = document.getElementById(`${skill.id}-max-btn`); // 獲取點滿按鈕

                            // 檢查是否可增加點數 (原有的canIncrease邏輯)
                            const canIncrease =
                                currentSkillLevels[skill.id] < skill.maxLevel &&
                                remainingSp > 0 &&
                                checkOverallSkillConditions(skill, jobStageKey);

                            if (increaseBtn) increaseBtn.disabled = !canIncrease;
                            if (decreaseBtn) decreaseBtn.disabled = currentSkillLevels[skill.id] === 0;

                            // --- 判斷點滿按鈕是否可點擊 ---
                            const spNeededToMax = skill.maxLevel - currentSkillLevels[skill.id];
                            const canMaxSkill =
                                spNeededToMax > 0 && // 還有點數可點
                                remainingSp >= spNeededToMax && // 剩餘SP足夠
                                checkOverallSkillConditions(skill, jobStageKey); // 其他條件也符合

                            if (maxBtn) maxBtn.disabled = !canMaxSkill; // 啟用或禁用點滿按鈕

                            // --- 更新前置技能顯示 ---
                            updateSkillPrerequisitesDisplay(skill.id);
                            // ... (技能詳情顯示邏輯保持不變) ...
                            const descArea = document.getElementById(`${skill.id}-description`);
                            if (descArea) {
                                if (currentSkillLevels[skill.id] > 1) {
                                    descArea.style.display = 'flex';
                                    descArea.removeAttribute('data-user-toggled');
                                } else {
                                    const userToggled = descArea.getAttribute('data-user-toggled');
                                    if (userToggled === 'open') {
                                        descArea.style.display = 'flex';
                                    } else {
                                        descArea.style.display = 'none';
                                    }
                                }
                                updateSingleSkillDetail(skill.id);
                            }
                        }
                    });
                }
            });
        }
        // --- 檢查所有技能點數和等級的條件 ---
        function checkOverallSkillConditions(skillBeingChecked, jobStageKeyOfSkill) {
            // 1. 檢查角色等級是否符合技能要求
            if (currentLevel < skillBeingChecked.requiredLevel) {
                return false;
            }

            // 2. 檢查單一技能的前置技能是否點足夠
            for (const preReqSkillId in skillBeingChecked.preRequisite) {
                if (currentSkillLevels[preReqSkillId] < skillBeingChecked.preRequisite[preReqSkillId]) {
                    return false;
                }
            }

            // 3. 檢查轉職點數總和要求
            const currentJobIndex = currentProfessionData.jobStagesOrder.indexOf(jobStageKeyOfSkill);

            // 如果是2轉技能，檢查1轉總點數
            if (jobStageKeyOfSkill.startsWith("2轉") && currentJobIndex > 0) {
                const prevJobStageKey = currentProfessionData.jobStagesOrder[currentJobIndex - 1]; // 獲取1轉的鍵名
                const spentInPrevJob = getSpentSpInJobStage(prevJobStageKey);
                // 使用 currentProfessionData 中定義的動態閾值
                if (spentInPrevJob < currentProfessionData.spRequiredFor2ndJob) {
                    return false;
                }
            }
            // 如果是3轉技能，檢查1轉+2轉總點數
            else if (jobStageKeyOfSkill.startsWith("3轉") && currentJobIndex > 1) {
                let totalSpentInPrevJobs = 0;
                for (let i = 1; i < currentJobIndex; i++) { // 從1轉開始累計到該轉職前一轉
                    totalSpentInPrevJobs += getSpentSpInJobStage(currentProfessionData.jobStagesOrder[i]);
                }
                // 使用 currentProfessionData 中定義的動態閾值
                if (totalSpentInPrevJobs < currentProfessionData.spRequiredFor3rdJob) {
                    return false;
                }
            }
            // 如果是4轉技能，檢查1轉+2轉+3轉總點數
            else if (jobStageKeyOfSkill.startsWith("4轉") && currentJobIndex > 2) {
                let totalSpentInPrevJobs = 0;
                for (let i = 1; i < currentJobIndex; i++) { // 從1轉開始累計到該轉職前一轉
                    totalSpentInPrevJobs += getSpentSpInJobStage(currentProfessionData.jobStagesOrder[i]);
                }
                // 使用 currentProfessionData 中定義的動態閾值 (spRequiredFor4thJob)
                if (totalSpentInPrevJobs < currentProfessionData.spRequiredFor4thJob) {
                    return false;
                }
            }
            // 您可以在這裡添加超技能、5轉等點數要求

            return true;
        }

        // --- 更新單一技能的詳情內容 ---
        function updateSingleSkillDetail(skillId) {
            let skill = null;
            // 在當前職業的技能數據中查找技能
            for (const jobStageKey in currentProfessionData.skills) {
                skill = currentProfessionData.skills[jobStageKey].find(s => s.id === skillId);
                if (skill) break;
            }
            if (!skill) return;

            const currentLevelPointed = currentSkillLevels[skillId];
            const levelInDescSpan = document.getElementById(`${skillId}-level-in-desc`); // 獲取顯示等級的 span
            const effectSpan = document.getElementById(`${skillId}-current-effect`);
            const fullDescP = document.getElementById(`${skillId}-full-description`);

            if (levelInDescSpan) { // 更新描述區塊中的等級數字
                levelInDescSpan.textContent = currentLevelPointed;
            }

            let effectText = "（點擊技能名稱查看效果）"; // 預設效果文字
            // 為了避免資訊重複，詳細描述區域始終顯示技能的基礎描述
            const descriptionText = skill.description || "無詳細描述。";

            if (currentLevelPointed > 0 && skill.levels && skill.levels[currentLevelPointed]) {
                const levelData = skill.levels[currentLevelPointed];
                effectText = levelData.effect || "（無此等級效果描述）";
                // 不再從 levelData.fullDescription 讀取，因為它與 effect 重複
            }

            if (effectSpan) effectSpan.textContent = effectText;
            if (fullDescP) fullDescP.innerHTML = descriptionText; // 將詳細描述區域設定為基礎描述
        }

        // --- 增加技能點數 ---
        function increaseSkill(skillId) {
            let skill = null;
            let jobStageKey = null;
            for (const stageKey in currentProfessionData.skills) {
                const foundSkill = currentProfessionData.skills[stageKey].find(s => s.id === skillId);
                if (foundSkill) {
                    skill = foundSkill;
                    jobStageKey = stageKey;
                    break;
                }
            }

            if (!skill) return;

            const canIncrease =
                currentSkillLevels[skillId] < skill.maxLevel &&
                remainingSp > 0 &&
                checkOverallSkillConditions(skill, jobStageKey);

            if (canIncrease) {
                currentSkillLevels[skillId]++;
                spentSp++;
                remainingSp--;
                updateUI();
            }
        }

        // --- 減少技能點數 ---
        function decreaseSkill(skillId) {
            if (currentSkillLevels[skillId] > 0) {
                currentSkillLevels[skillId]--;
                spentSp--;
                remainingSp++;
                updateUI();
            }
        }

        // --- 新增：從混合鍵中提取英文鍵的輔助函式 ---
        // 修正：此函式現在會返回 URL 使用的標準英文簡稱 (e.g., archmage_fp)
        function findEnglishKeyByMixedKey(mixedKey) {
            if (!mixedKey) return null;
            // 遍歷 professionNameMap，找到哪個英文 key 對應的中文名稱是 mixedKey 的開頭
            return Object.keys(professionNameMap).find(key => mixedKey.startsWith(professionNameMap[key])) || null;
        }

        // --- 分享配點 ---
        async function shareBuild() {
            const baseUrl = window.location.origin + window.location.pathname;

            const skillsToShare = [];
            for (const skillId in currentSkillLevels) {
                if (currentSkillLevels[skillId] > 0) {
                    skillsToShare.push(`${skillId}:${currentSkillLevels[skillId]}`);
                }
            }

            // --- 新增：從混合 key 中提取英文 key，確保分享連結使用標準格式 ---
            const englishProfKey = findEnglishKeyByMixedKey(currentProfessionKey);
            if (!englishProfKey) {
                alert("錯誤：無法生成分享連結，找不到職業的英文代碼。");
                return;
            }

            const params = new URLSearchParams({
                prof: englishProfKey,
                lvl: currentLevel,
                skills: skillsToShare.join(',')
            });

            const shareUrl = `${baseUrl}?${params.toString()}`;
            await navigator.clipboard.writeText(shareUrl);
            alert('配點連結已複製到剪貼簿！\n現在可以將連結傳給朋友了。');
        }
        // --- 點滿技能函式 ---
        function maxSkill(skillId) {
            let skill = null;
            let jobStageKey = null;
            for (const stageKey in currentProfessionData.skills) {
                const foundSkill = currentProfessionData.skills[stageKey].find(s => s.id === skillId);
                if (foundSkill) {
                    skill = foundSkill;
                    jobStageKey = stageKey;
                    break;
                }
            }

            if (!skill) return;

            const spNeeded = skill.maxLevel - currentSkillLevels[skill.id];

            // 檢查是否可以點滿
            const canMax =
                spNeeded > 0 && // 還有點數可點
                remainingSp >= spNeeded && // 剩餘SP足夠
                currentLevel >= skill.requiredLevel && // 角色等級符合
                checkOverallSkillConditions(skill, jobStageKey); // 其他條件也符合 (前置技能，轉職總SP等)

            if (canMax) {
                currentSkillLevels[skillId] = skill.maxLevel;
                spentSp += spNeeded;
                remainingSp -= spNeeded;
                updateUI(); // 更新UI
            } else {
                // 如果不能點滿，可以在這裡添加一些提示（例如：點數不足、等級不足、前置技能未滿等）
                // 為了簡潔，這裡暫時不顯示具體提示
                console.log(`無法點滿技能 ${skill.name}: 點數不足、等級不足或前置條件未滿足。`);
            }
        }

        // --- 新增：建立技能中文名到ID的映射表 ---
        function createSkillNameMap(professionKey) {
            const nameToIdMap = {};
            const professionData = allProfessionsData[professionKey];
            if (!professionData) return nameToIdMap;

            // 遍歷該職業所有轉職階段的技能
            for (const jobStageKey in professionData.skills) {
                professionData.skills[jobStageKey].forEach(skill => {
                    nameToIdMap[skill.name] = skill.id;
                });
            }
            return nameToIdMap;
        }

        // --- 輔助函式：根據技能ID獲取技能數據 ---
        function getSkillById(skillId) {
            // 遍歷所有職業的所有轉職階段來查找技能
            for (const professionKey in allProfessionsData) {
                const professionSkills = allProfessionsData[professionKey].skills;
                for (const jobStageKey in professionSkills) {
                    const foundSkill = professionSkills[jobStageKey].find(s => s.id === skillId);
                    if (foundSkill) {
                        return foundSkill; // 找到技能即返回
                    }
                }
            }
            return null; // 未找到
        }

        // --- 輔助函式：更新單一技能的前置技能顯示 ---
        function updateSkillPrerequisitesDisplay(skillId) {
            const skill = getSkillById(skillId);
            const preReqsDiv = document.getElementById(`${skillId}-prereqs`);

            if (!skill || !preReqsDiv) return;

            // 如果沒有前置技能，清空並隱藏區塊
            if (!skill.preRequisite || Object.keys(skill.preRequisite).length === 0) {
                preReqsDiv.innerHTML = '';
                preReqsDiv.style.display = 'none'; // 隱藏沒有前置技能的區塊
                return;
            }

            let preReqsHtml = '前置: ';
            let allMet = true; // 追蹤所有前置技能是否都已滿足

            for (const preReqSkillId in skill.preRequisite) {
                const requiredLevel = skill.preRequisite[preReqSkillId];
                const currentLevel = currentSkillLevels[preReqSkillId] || 0; // 確保有值，沒有點是0
                const preReqSkillData = getSkillById(preReqSkillId);
                const preReqName = preReqSkillData ? preReqSkillData.name : preReqSkillId; // 顯示技能名稱或ID

                const isMet = currentLevel >= requiredLevel;
                if (!isMet) allMet = false; // 只要有一個不滿足，就設為false

                preReqsHtml += `<span class="${isMet ? 'prereq-met' : 'prereq-unmet'}">${preReqName} (${currentLevel}/${requiredLevel})</span> `;
            }

            preReqsDiv.innerHTML = preReqsHtml;
            preReqsDiv.style.display = 'flex'; // 有前置技能時顯示
        }

        // --- 新增：顯示推薦配點詳情 ---
        function showBuildDetails(buildIndex) {
            const container = document.getElementById('buildDetailsContainer');
            const select = document.getElementById('recommendedBuildSelect');

            if (buildIndex === "") {
                container.style.display = 'none';
                return;
            }

            const build = recommendedBuilds[currentProfessionKey][parseInt(buildIndex, 10)];
            if (!build) return;

            // 填充詳情內容
            document.getElementById('buildDetailName').textContent = build.name;
            document.getElementById('buildDetailDescription').textContent = build.description;
            document.getElementById('buildDetailPriority').textContent = build.priority;

            // 顯示詳情區塊
            container.style.display = 'flex';

            // 處理 "載入此配點" 按鈕的點擊事件
            const loadBtn = document.getElementById('loadBuildBtn');
            // 複製並取代按鈕以移除舊的監聽器，避免重複觸發
            const newLoadBtn = loadBtn.cloneNode(true);
            loadBtn.parentNode.replaceChild(newLoadBtn, loadBtn);

            newLoadBtn.onclick = () => {
                // 建立當前職業的技能名稱映射表
                const skillNameMap = createSkillNameMap(currentProfessionKey);

                // 載入配點指定的等級
                currentLevel = build.level;
                document.getElementById('levelInput').value = currentLevel;

                // 重置技能點數並應用新配點
                Object.keys(currentSkillLevels).forEach(id => currentSkillLevels[id] = 0);
                build.skills.split(',').forEach(pair => {
                    const [name, lvl] = pair.split(':');
                    const skillId = skillNameMap[name.trim()]; // 使用映射表找到ID

                    if (skillId && lvl && currentSkillLevels.hasOwnProperty(skillId)) {
                        currentSkillLevels[skillId] = parseInt(lvl, 10);
                    } else {
                        console.warn(`警告：在推薦配點 "${build.name}" 中找不到技能名稱 "${name}" 或其ID "${skillId}"。`);
                    }
                });

                // 重新計算SP並更新UI
                spentSp = Object.values(currentSkillLevels).reduce((a, b) => a + b, 0);
                remainingSp = calculateMaxSp(currentLevel) - spentSp;
                updateUI();
                closeBuildDetails(); // 載入後關閉詳情
            };
        }

        // --- 新增：關閉推薦配點詳情 ---
        function closeBuildDetails() {
            document.getElementById('buildDetailsContainer').style.display = 'none';
            document.getElementById('recommendedBuildSelect').value = "";
        }

        // --- 新增：開啟貢獻配點表單 ---
        function openContributionForm() {
            const instructions = `感謝您願意分享配點！

操作教學：
1. 在模擬器中完成您的配點。
2. 點擊「分享」按鈕，配點連結將會自動複製。
3. 在接下來開啟的表單中，將連結貼到對應的欄位即可。

準備好要分享了嗎？ (點擊 "確定" 將會開啟表單)`;

            if (confirm(instructions)) {
                const formUrl = 'https://docs.google.com/forms/d/e/1FAIpQLSdgOrzO3ywc5gwFq1Si9gken-Da9QKephcJu8HHjMZru-TDMA/viewform?usp=preview';
                window.open(formUrl, '_blank');
            }
        }

        // --- 新增：處理技能等級手動輸入 ---
        function getJobStageKeyForSkill(skillId) {
            for (const stageKey in currentProfessionData.skills) {
                if (currentProfessionData.skills[stageKey].some(s => s.id === skillId)) {
                    return stageKey;
                }
            }
            return null;
        }

        function setSkillLevel(skillId, inputElement) {
            let newLevel = parseInt(inputElement.value, 10);

            const skill = getSkillById(skillId);
            if (!skill) {
                inputElement.value = currentSkillLevels[skillId]; // Revert
                return;
            }

            const oldLevel = currentSkillLevels[skillId];

            // 1. 驗證並限制輸入值
            if (isNaN(newLevel)) { newLevel = oldLevel; }
            if (newLevel < 0) { newLevel = 0; }
            if (newLevel > skill.maxLevel) { newLevel = skill.maxLevel; }
            if (newLevel !== parseInt(inputElement.value, 10)) {
                inputElement.value = newLevel;
            }

            const spChange = newLevel - oldLevel;
            if (spChange === 0) { return; }

            // 2. 檢查變更是否可行
            if (spChange > 0) { // 增加點數
                if (remainingSp < spChange) {
                    alert("剩餘點數不足！");
                    inputElement.value = oldLevel; // 還原
                    return;
                }
                const jobStageKey = getJobStageKeyForSkill(skillId);
                if (!checkOverallSkillConditions(skill, jobStageKey)) {
                    alert("未滿足前置條件或等級需求！");
                    inputElement.value = oldLevel; // 還原
                    return;
                }
            } else { // 減少點數
                // 暫時應用變更以檢查是否會破壞其他技能的前置條件
                currentSkillLevels[skillId] = newLevel;
                let isChangeValid = true;
                for (const skId in currentSkillLevels) {
                    if (currentSkillLevels[skId] > 0) {
                        const otherSkill = getSkillById(skId);
                        const otherSkillJobStage = getJobStageKeyForSkill(skId);
                        if (otherSkill && !checkOverallSkillConditions(otherSkill, otherSkillJobStage)) {
                            isChangeValid = false;
                            alert(`無法減少 ${skill.name} 的等級，因為技能 "${otherSkill.name}" 需要它作為前置條件。`);
                            break;
                        }
                    }
                }
                // 在做決定前還原暫時的變更
                currentSkillLevels[skillId] = oldLevel;

                if (!isChangeValid) {
                    inputElement.value = oldLevel;
                    return;
                }
            }

            // 3. 應用變更
            currentSkillLevels[skillId] = newLevel;
            spentSp += spChange;
            remainingSp -= spChange;

            // 4. 更新整個UI
            updateUI();
        }

        // --- 重置模擬器 (針對當前職業) ---
        function resetSimulator() {
            if (confirm("您確定要重置所有技能點數嗎？")) {
                loadProfessionData(currentProfessionKey); // 重新載入當前職業，達到重置效果
            }
        }

        // --- 玩家等級輸入處理 ---
        function updateLevelFromInput() {
            const inputElement = document.getElementById('levelInput');
            let newLevel = parseInt(inputElement.value);

            if (isNaN(newLevel) || newLevel < 1) {
                newLevel = 1;
                inputElement.value = 1;
            }
            if (newLevel > 300) {
                newLevel = 300;
                inputElement.value = 300;
            }

            if (newLevel !== currentLevel) {
                currentLevel = newLevel;
                remainingSp = calculateMaxSp(currentLevel) - spentSp;
                if (remainingSp < 0) remainingSp = 0;

                updateUI();
            }
        }

        // --- 切換技能詳情顯示/隱藏 ---
        function toggleSkillDescription(skillId) {
            const descArea = document.getElementById(`${skillId}-description`);
            if (!descArea) return;

            const currentLevel = currentSkillLevels[skillId];

            if (currentLevel > 1) {
                descArea.style.display = 'flex';
                descArea.removeAttribute('data-user-toggled');
                updateSingleSkillDetail(skillId);
            } else {
                if (descArea.style.display === 'flex') {
                    descArea.style.display = 'none';
                    descArea.setAttribute('data-user-toggled', 'closed');
                } else {
                    descArea.style.display = 'flex';
                    descArea.setAttribute('data-user-toggled', 'open');
                    updateSingleSkillDetail(skillId);
                }
            }
        }

        /**
         * 設定「回到頂部」按鈕的功能。
         * 按鈕會在使用者向下滾動一定距離後出現。
         */
        function setupBackToTopButton() {
            const backToTopBtn = document.getElementById('backToTopBtn');
            if (!backToTopBtn) return;

            // 當使用者滾動頁面時，決定是否顯示按鈕
            window.addEventListener('scroll', () => {
                // 為了跨瀏覽器相容性，同時檢查 document.body.scrollTop 和 document.documentElement.scrollTop
                if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
                    backToTopBtn.classList.add('show');
                } else {
                    backToTopBtn.classList.remove('show');
                }
            });

            // 當使用者點擊按鈕時，平滑滾動到頁面頂部
            backToTopBtn.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }

        // 初始載入
        initializeSimulator();
        setupBackToTopButton();
    </script>
</body>


</html>